<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web5 Agent Example</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg" color="#000000">
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <meta name="msapplication-TileColor" content="#603cba">
  <meta name="msapplication-config" content="/assets/images/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="" />
  <link rel="stylesheet" href="./assets/styles/global.css" />
  <link rel="stylesheet" href="./assets/styles/light.css" media="(prefers-color-scheme: light)" />
  <link rel="stylesheet" href="./assets/styles/dark.css" media="(prefers-color-scheme: dark)" />
  <script type="module" src="https://unpkg.com/dark-mode-toggle"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;700&display=swap" rel="stylesheet">
  <script src="./assets/js/utils.js"></script>
</head>

<body>
  <main>
    <h2>Create Web5 App Instance</h2>
    <pre><code class="language-javascript">const web5 = new Web5();</code></pre>

    <h2>Create DID</h2>
    <pre><code class="language-javascript">let alice = await web5.did.create('ion');

console.log('ID:', alice.internalId);
console.log('ID (long form):', alice.id);</code></pre>
    <div id="create_did_output"></div>

    <h2>Associate DID with DWN Instance</h2>
    <pre><code class="language-javascript">web5.did.manager.set(alice.id, {
  connected: true,
  endpoint: 'app://dwn',
  keys: {
    ['#dwn']: {
      keyPair: did.keys.find(key => key.id === 'dwn').keyPair
    }
  }
});</code></pre>

    <h2>CRUD with Browser DWN</h2>
    <p>We'll first start by creating, reading, updating, and deleting a record using a DWN running in your web browser.</p>

    <h3>Create a Record</h3>
    <pre><code class="language-javascript">let { record, status } = await web5.dwn.records.create(alice.id, {
  author: alice.id,
  data: 'Hello, world!',
  message: {
    dataFormat: 'text/plain'
  }
});

console.log('Status:' status);
console.log('Record ID:', record.id);</code></pre>
    <div id="create_record_output"></div>

    <h3>Read Record Data</h3>
    <pre><code class="language-javascript">console.log(await record.data.text());</code></pre>
    <div id="record_text_data_output"></div>

    <h3>Update Record</h3>
    <pre><code class="language-javascript">const updateResult = await record.update({data: "Hello, I'm updated!"});

console.log(await record.data.text());</code></pre>
    <div id="record_text_data_updated_output"></div>

    <h3>Delete Record</h3>
    <pre><code class="language-javascript">({ status } = await record.delete());

console.log('Status:' status);</code></pre>
    <div id="delete_record_output"></div>


    <h2>Remote DWN Server</h2>
    <p>
      Now that we've seen how easy it is to work with records when the DWN is running in your browser, let's try something
      a little more interesting.  We'll create DIDs for Bob and Carol and walk through how they can send messages to
      each other via a remote DWN server.
    </p>
    <p>
      In a real-world scenario, this DWN server would likely be publicly addressable over the Internet.  Bob and Carol
      would each have a local Web5 Agent (e.g., browser, desktop, or mobile app) that would secure their keys and manage
      their personal DWN datastore, and by using the remote DWN server, they can interact asynchronously even if their
      local agent is offline.
    </p>
        
      
    <h3>Create DIDs with Services for Bob and Carol</h3>

    We'll create DIDs for Bob and Carol that have a service endpoint defined that points to the local DWN Server
    instance you setup when following the examples
    <a href="https://github.com/TBD54566975/web5-js/tree/main/examples/test-dashboard">README</a>.  Make sure you
    change the port number if you choose to override the default of <code class="language-javascript">3000</code>.

    <pre><code class="language-javascript">const bob = await web5.did.create('ion', {
  services: [
    {
      'id': 'dwn',
      'type': 'DecentralizedWebNode',
      'serviceEndpoint': {
        'nodes': ['http://localhost:3000']
      }
    }
  ]
});

const carol = await web5.did.create('ion', {
  services: [
    {
      'id': 'dwn',
      'type': 'DecentralizedWebNode',
      'serviceEndpoint': {
        'nodes': ['http://localhost:3000']
      }
    }
  ]
});

console.log('Bob ID:', bob.id);
console.log('Carol ID:', carol.id);</code></pre>
    <div id="create_did_services_output"></div>

    <p>
      If you resolve the DIDs created for
      <a id="resolveDidDocBob" target="_blank" rel="noopener">Bob</a>
      or
      <a id="resolveDidDocCarol" target="_blank" rel="noopener">Carol</a>
      to a DID document, you'll find that each has <code class="language-json">DecentralizedWebNode</code> service
      endpoint defined:
    </p>
    <pre><code class="language-json">"service": [
  {
    "id": "#dwn",
    "type": "DecentralizedWebNode",
    "serviceEndpoint": {
      "nodes": [
        "http://localhost:3000"
      ]
    }
  }
],</code></pre>
    <p>
      When we construct a <code class="language-javascript">web5.dwn.records.create()</code> that targets Bob's or
      Carol's DID, Web5 JS will resolve the DID document and find that the first DWN endpoint to connect to is
      <code class="language-markup">http://localhost:3000</code>.  Consequently, the message will be transported
      over HTTP since the target DID's DWN endpoint specifies the <code class="language-markup">http</code> protocol in
      its URL.  In a real-world example, this endpoint would typically be reachable over the Internet using a public IP
      address or DNS name that resolves to a public address.
    </p>

    <h3>Define and Configure a Protocol</h3>
    <p>
      By default, only the owner/controller of a DWN tenant is able to create, read, update, or delete records.  This is
      enforced by checking whether the message is signed by the tenant's DID.  For this example scenario, to permit
      Bob to create a record on Carol's DWN (and vice versa), we define a
      <code class="language-javascript">test</code> protocol that permits anyone to read and write
      <code class="language-javascript">test/post</code> messages.  Other than perhaps a public social media use case,
      in a real-world scenario you would not typically grant <code class="language-javascript">anyone</code> this
      level of access.
    </p>
    <pre><code class="language-javascript">const protocolName = 'test';
const protocolDefinition = {
  "labels": {
    "post": {
      "schema": "test/post"
    }
  },
  "records": {
    "post": {
      "allow": {
        "anyone": {
          "to": [
            "read",
            "write"
          ]
        }
      }
    }
  }
}</code></pre>
    <p>
      The <code class="language-javascript">test</code> protocol needs to be configured for both Bob's and Carol's DWNs
      to permit each to create and read messages to each other as follows.
    </p>
    <pre><code class="language-javascript">({ status } = await web5.dwn.protocols.configure(bob.id, {
  author: bob.id,
  message: {
    protocol: protocolName,
    definition: protocolDefinition
  }
}));

console.log('Configure Protocol Bob:', status);

({ status } = await web5.dwn.protocols.configure(carol.id, {
  author: carol.id,
  message: {
    protocol: protocolName,
    definition: protocolDefinition
  }
}));

console.log('Configure Protocol Carol:', status);</code></pre>
    <div id="configure_protocols_output"></div>

    <h3>Bob Creates a Record on Carol's DWN</h3>
    Now that a protocol has been configured to permit Bob to message Carol, let's actually do that.
    <pre><code class="language-javascript">({ record, status } = await web5.dwn.records.create(carol.id, {
  author: bob.id,
  data: 'Hi, Carol!',
  message: {
    recipient: carol.id,
    protocol: 'test',
    schema: 'test/post'
  }
}));</code></pre>

    <h3>Carol Reads the Message Received from Bob</h3>
    <pre><code class="language-javascript">let { entries } = await web5.dwn.records.query(carol.id, {
  author: carol.id,
  filter: {
    recipient: carol.id,
    protocol: 'test',
    schema: 'test/post'
  }
});

entries.forEach(async record => {
  console.log(await record.data.text());
});</code></pre>
    <div id="read_record_carol_output"></div>
    
    <h3>Carol Sends a Reply to Bob</h3>
    <pre><code class="language-javascript">({ record, status } = await web5.dwn.records.create(bob.id, {
      author: carol.id,
      data: 'Hey, Bob! Message received.',
      message: {
        recipient: bob.id,
        protocol: 'test',
        schema: 'test/post'
      }
    }));</code></pre>
    
    <h3>Bob Reads Carol's Reply</h3>
    <pre><code class="language-javascript">({ entries } = await web5.dwn.records.query(bob.id, {
      author: bob.id,
      filter: {
        recipient: bob.id,
        protocol: 'test',
        schema: 'test/post'
      }
    }));
    
    entries.forEach(async record => {
      console.log(await record.data.text());
    });</code></pre>
    <div id="read_record_bob_output"></div>

  </main>
  <aside>
    <dark-mode-toggle
    id="dark-mode-toggle"
    class="slider"
    legend="Theme"
    permanent="true"
    appearance="toggle"
  ></dark-mode-toggle>
  </aside>

  <script type="module">
    // import { Web5 } from 'https://unpkg.com/@tbd54566975/web5@0.6.3/dist/browser.mjs';
    import { Web5 } from './browser.mjs';
    import { initCodeCopy } from './assets/js/copy-to-clipboard.js';
    initCodeCopy();
    
    const web5 = new Web5();
    let message, record, status;

    // Create a new ION DID and public-private key pair.
    let alice = await web5.did.create('ion', {
      services: [
        {
          'id': 'dwn',
          'type': 'DecentralizedWebNode',
          'serviceEndpoint': {
            'nodes': ['http://localhost:3000'],
          },
        },
      ],
    });
    generateStdoutElement('create_did_output', 'Create DID Output');
    appendStdoutLine('create_did_output', `ID: ${alice.internalId}`);
    appendStdoutLine('create_did_output', `ID (long form): ${alice.id}`);

    // Set Managed DID as running in browser memory and for which keys are available to sign messages.
    web5.did.manager.set(alice.id, {
      connected: true,
      endpoint: 'app://dwn',
      keys: {
        ['#dwn']: {
          keyPair: alice.keys.find(key => key.id === 'dwn').keyPair,
        },
      },
    });

    // Create a plain text record to the in-memory DWN.
    ({record, status} = await web5.dwn.records.create(alice.id, {
      author: alice.id,
      data: 'Hello, world!',
      message: {
        dataFormat: 'text/plain'
      }
    }));
    generateStdoutElement('create_record_output', 'Create Record Output');
    appendStdoutLine('create_record_output', `Status: ${JSON.stringify(status, null, 2)}`);
    appendStdoutLine('create_record_output', `Record ID: ${record.id}`);

    // Read record data from in-memory DWN.
    const readResult = await record.data.text();
    generateStdoutElement('record_text_data_output', 'Read Record Data Output');
    appendStdoutLine('record_text_data_output', readResult);

    // Update record data.
    const updateResult = await record.update({data: "Hello, I'm updated!"});
    generateStdoutElement('record_text_data_updated_output', 'Update Record Data Output');
    appendStdoutLine('record_text_data_updated_output', await record.data.text());

    // Delete record.
    const deleteResult = await record.delete();
    generateStdoutElement('delete_record_output', 'Delete Record Output');
    appendStdoutLine('delete_record_output', `Status: ${JSON.stringify(status, null, 2)}`);

    /**
     * START - TODO: Replace with Web5 JS methods once `web5-js` has been updated to communicate with `dwn-server`.
     */
    // Temporary imports:
    import { ProtocolsConfigure } from 'https://cdn.jsdelivr.net/npm/@tbd54566975/dwn-sdk-js@0.0.30/dist/bundles/browser.js';

    // Create a new ION DID and public-private key pair with services for Bob and Carol.
    const bob = await web5.did.create('ion', {
      services: [
        {
          'id': 'dwn',
          'type': 'DecentralizedWebNode',
          'serviceEndpoint': {
            'nodes': ['http://localhost:3000'],
          },
        },
      ],
    });
    const carol = await web5.did.create('ion', {
      services: [
        {
          'id': 'dwn',
          'type': 'DecentralizedWebNode',
          'serviceEndpoint': {
            'nodes': ['http://localhost:3000'],
          },
        },
      ],
    });
    generateStdoutElement('create_did_services_output', 'Create DID Output');
    appendStdoutLine('create_did_services_output', `Bob ID: ${bob.id}`);
    appendStdoutLine('create_did_services_output', `Carol ID: ${carol.id}`);
    resolveDidDocBob.href = `https://dev.uniresolver.io/#did=${bob.id}`;
    resolveDidDocCarol.href = `https://dev.uniresolver.io/#did=${carol.id}`;

    // Set Managed DID as running in browser memory and for which keys are available to sign messages.
    web5.did.manager.set(bob.id, {
      connected: true,
      endpoint: 'http://localhost:3000',
      keys: {
        ['#dwn']: {
          keyPair: bob.keys.find(key => key.id === 'dwn').keyPair,
        },
      },
    });

    web5.did.manager.set(carol.id, {
      connected: true,
      endpoint: 'http://localhost:3000',
      keys: {
        ['#dwn']: {
          keyPair: carol.keys.find(key => key.id === 'dwn').keyPair,
        },
      },
    });

    // Define 'test' protocol.
    const protocolName = 'test';
    const protocolDefinition = {
      "labels": {
        "post": {
          "schema": "test/post"
        }
      },
      "records": {
        "post": {
          "allow": {
            "anyone": {
              "to": [
                "read",
                "write"
              ]
            }
          }
        }
      }
    };

    generateStdoutElement('configure_protocols_output', 'Configure Protocols Output');
    ({ status } = await web5.dwn.protocols.configure(bob.id, {
      author: bob.id,
      message: {
        protocol: protocolName,
        definition: protocolDefinition,
      }
    }));
    appendStdoutLine('configure_protocols_output', `Configure Protocol Bob: ${JSON.stringify(status, null, 2)}`);

    ({ status } = await web5.dwn.protocols.configure(carol.id, {
      author: carol.id,
      message: {
        protocol: protocolName,
        definition: protocolDefinition,
      }
    }));
    appendStdoutLine('configure_protocols_output', `Configure Protocol Carol: ${JSON.stringify(status, null, 2)}`);
  
    /**
     * Bob sends a message to Carol.
     */

    // Message is written first to Bob's DWN so that he retains a copy.
    const { record: bobToCarol, status: bobToCarolStatus } = await web5.dwn.records.create(bob.id, {
      author: bob.id,
      data: 'Hi, Alice!',
      message: {
        recipient: carol.id,
        protocol: 'test',
        schema: 'test/post',
      },
    });

    // Message is then written to Carols DWN.
    const { record: bobToCarolBob, status:bobToCarolBobStatus } = await web5.dwn.records.createFrom(carol.id, {
      data: 'Hi, Carol!',
      record: bobToCarol,
    });

    /**
     * Carol reads the message Bob sent.
     */

    const { entries } = await web5.dwn.records.query(carol.id, {
      author: carol.id,
      message: {
        filter: {
          recipient: carol.id,
          protocol: 'test',
          schema: 'test/post',
        }
      }
    });

    generateStdoutElement('read_record_carol_output', 'Carol Read Message Output');
    entries.forEach(async record => {
      appendStdoutLine('read_record_carol_output', await record.data.text());
    });

    /**
     * Carol sends a message to Bob.
     */

    // Message is written first to Carol's DWN so that he retains a copy.
    const { record: carolToBob, status: carolToBobStatus } = await web5.dwn.records.create(carol.id, {
      author: carol.id,
      data: 'Hey, Bob!',
      message: {
        recipient: bob.id,
        protocol: 'test',
        schema: 'test/post',
      },
    });

    // Then, the message is written to Bob's DWN.
    const { record: carolToBobBob, status:carolToBobBobStatus } = await web5.dwn.records.createFrom(bob.id, {
      data: 'Hey, Bob!',
      record: carolToBob,
    });

    /**
     * Bob reads the message Carol sent.
     */

    const { entries: entriesBob } = await web5.dwn.records.query(bob.id, {
      author: bob.id,
      message: {
        filter: {
          recipient: bob.id,
          protocol: 'test',
          schema: 'test/post',
        }
      }
    });

    generateStdoutElement('read_record_bob_output', 'Bob Read Message Output');
    entriesBob.forEach(async record => {
      appendStdoutLine('read_record_bob_output', await record.data.text());
    });

    // Update stdout row counts after all example script actions have completed.
    setStdoutRowCounts('stdout');

    // Convenience functions to decode data returned by queries
    function base64UrlToString(encodedData) {
      return web5.dwn.sdk.Encoder.bytesToString(web5.dwn.sdk.Encoder.base64UrlToBytes(encodedData));
    }

    function base64UrlToObject(encodedData) {
      return web5.dwn.sdk.Encoder.base64UrlToObject(encodedData);
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>

</html>
